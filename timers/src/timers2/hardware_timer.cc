//hardware_timer.cc

#include "hardware_timer.h"

//system includes
#include <signal.h>
#include <sys/time.h>

#ifdef __linux__
#define _POSIX_TIMERS 1
#include <posix_time.h>
#endif

//////////////// PUBLIC

hardware_timer::hardware_timer()
{
  sig_blocked = 0;
}

int 
hardware_timer::catch_timer_interrupt(void(*handler)(int))
{
	/* uses sigaction to set up a signal handler to catch the 
	SIGALRM signal. 
	*/

  struct sigaction sa;

  sigset_t mask;
  sigemptyset(&mask);

  sa.sa_handler=handler;
  sa.sa_mask=mask;
  sa.sa_flags=0;
  

  return(sigaction(SIGALRM, &sa, NULL));
}

void 
hardware_timer::set_hardware_timer(long interval)
{
  /* starts the ITIMER_REAL timer running with the given interval in 
     microseconds. call only when the timer interrupt is blocked or
     the interval timer is stopped
  */

  int ret;

  struct itimerval value, ovalue;

  value.it_interval.tv_sec = 0;
  value.it_interval.tv_usec = interval;

  value.it_value = value.it_interval;

  ret = setitimer(ITIMER_REAL, &value, &ovalue);
}

long 
hardware_timer::get_hardware_timer(void)
{
  /* returns the time remaining on the hardware timer if it is runnig
     or 0 if it is not.
  */

  struct itimerval ovalue;
  
  getitimer(ITIMER_REAL, &ovalue);
  
  return(ovalue.it_interval.tv_usec);
}


void 
hardware_timer::stop_hardware_timer(void)
{
  /* stops the hardware timer if it is running
   */
  struct itimerval value;
  value.it_interval.tv_sec = 0;
  value.it_interval.tv_usec = 0;
  value.it_value = value.it_interval;

  setitimer(ITIMER_REAL, &value, NULL);
}

int 
hardware_timer::is_timer_interrupt_blocked(void)
{
  /* returns 1 if SIGALRM is blocked, otherwise 0
   */
  return sig_blocked;
}

void 
hardware_timer::block_timer_interrupt(void)
{
  /* blocks SIGALRM signal
   */
  sigset_t newmask;
  sigemptyset(&newmask);
  sigaddset(&newmask, SIGALRM); 
  
  sigprocmask(SIG_BLOCK, &newmask, &old_sigmask);
  sig_blocked = 1;
}

void 
hardware_timer::unblock_timer_interrupt(void)
{
  /* unblocks the SIGALRM signal
   */

  sigprocmask(SIG_SETMASK, &old_sigmask, NULL);
  sig_blocked = 0;
}

void 
hardware_timer::wait_for_interrupt(void)
{
  /* calls sigsuspend to wait until a signal is caught. 
     This function is normally entered with the timer signal blocked
     as the signal may be generated by other sources.  
  */

  sigset_t mask;
  sigemptyset(&mask);
  sigsuspend(&mask);
}	

//////////////// PRIVATE
